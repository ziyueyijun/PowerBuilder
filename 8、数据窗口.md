# 数据窗口

## 1、基础

```c
//接受主缓冲区的数据
dw_1.accepttext()

//重置数据窗口（ 恢复到最初始的控件状态，需重新指定数据窗口 ）  
dw_1.reset()
    
//指定数据窗口
dw_1.dataobject = "数据窗口名称"
    
//重绘数据窗口（）
dw_1.setredraw(false) //停止绘制
	//在这里处理您的业务...
dw_1.setredraw(true) //开始绘制
    
//共享数据窗口数据（ 不共享格式 ）
dw_1.sharedata(dw_2) //将 dw_1 数据窗口中的内容共享给 dw_2 数据窗口
  
//重新分组（当分组窗口插入新的数据，或者添加了指定的过滤、排序条件使得数据窗口发生了变化时，需要重新进行分组）
dw_emp.GroupCalc()
```

## 2、赋值与取值

```c
//赋值
dw_1.setitem(行,'列名称',值)
dw_1object.列名[行号] = 值

//取值
dw_1.object.字段名(行数) //直接取值
dw_1.object.标题名.text  //标题文本内容
dw_1.GetItemString(行数,列名) //字符串
dw_1.GetItemNumber(行数,列名) //数值
dw_1.GetItemDate(行数,列名) //日期
dw_1.GetItemDateTime(行数,列名) //日期时间
dw_1.GetItemDecimal(行数,列名) //小数
```

## 3、增删改查

### 3.1、增加 数据

```c
dw_1.insertrow(0)
```

### 3.2、删除数据

```c
//例1：删除第 1 行数据
dw_1.deleterow(1)
    
//例2：保留数据窗口第1行，并循环删除其他行
for ll_i = dw_1.rowcount() to 1  step - 1
	if ll_i = 1 then
		dw_1.object.字段名[1] = 值
	else
		dw_1.deleterow(ll_i)
	end if
next
        
//例3：循环删除
//先记录本次需要删除的序号
long ll_delete[],i,row,ll_count
ll_count = dw_1.rowcount()       
for row = 1 to ll_count
	if f_isnull(dw_1.object.字段名[row],0) = 0 then
        ll_delete[i] = row
		i ++
	end if
next
//再循环进行删除
long ll_delete_count
ll_delete_count = upperbound(ll_delete)
for row = 1 to  ll_delete_count
	dw_1.deleterow(ll_delete[ll_delete_count + 1 - row])
next
```

### 3.3、更新数据

[3.3.1、更新属性（ 点击跳转 ）](数据窗口/更新属性.md)

3.3.2、更新实例

```c
string ls_err
if dw_1.update() = 1 then
	commit using sqlca;
	messagebox('提示','更新成功')
else
	ls_err = sqlca.sqlerrtext
	rollback using sqlca;
	messagebox('提示','更新失败' + ls_err)
end if

//重置更新标志
dw_1.ResetUpdate()
```

### 3.4、检索数据

```c
//设置数据窗口控件外部事务对象，必须指定connect,commit,disconnect
dw_1.settransobject(sqlca)
dw_1.retrieve()

//设置数据窗口控件内部事务的值。自动connect,commit,disconnect
dw_1.settrans(sqlca)
dw_1.retrieve()
```

## 4、行

### 4.1、行处理

```c
//获取总行数 
dw_1.rowcount() 
//获取当前行（ 注：这里返回的是光标所在行的行号 ）
dw_1.getrow() 
    
//设置当前行（ 将光标移动到当前行,但不滚动到当前行 ）
dw_1.setrow(1) 
//滚动到目标行（此属性不会高亮显示目标行，但会将隐藏的行在数据窗口中显示）
dw_1.scrolltorow(1) 
    
//将第一行变成选中状态
//选择指定的行，并设置是否高亮显示。参数值1=0时，则设置所有行，参数值2：true=高亮显示，false=取消高亮 ）
dw_1.selectrow(1, true) 
//检查第一行是否被选择
if dw_1.isselected(1) = false then
    messagebox("提示","我没有被选择")
else
    messagebox("提示","我已经被选择，并且高亮显示了")
end if
    
//返回从第 0 行到数据窗口最后 1 行，已经选择的行号（ 注：仅返回查找到的第 1 个结果 ）
dw_1.getSelectedRow(0) 
//返回从第 10 行到数据窗口最后 1 行，已经选择的行号（ 注：仅返回查找到的第 1 个结果 ）
dw_1.getSelectedRow(10) 
//循环获取数据窗口选中的所有行
long ll_select
//获取当前数据窗口选中的行
ll_select = dw_1.getSelectedRow(0) 
do while ll_select > 0
	//在这里处理你的业务...
    
	//继续查找下一行
	ll_select = dw_1.getSelectedRow(ll_select) 
loop

//在数据窗口表达式中
IsRowNew() //判断当前行是不是新增的行
IsRowModified() //判断当前行是不是已经修改过
```

### 4.2、高亮显示

```c
//在数据窗口的 click 事件中，写入以下代码
if row > 0 then
	dw_1.selectrow(0,false)
    dw_1.setrow(row)
	dw_1.selectrow(row,true)
    dw_1.scrolltorow(row)
end if
    
//在数据窗口 rowfocuschanged 事件中，写入以下代码
if currentrow > 0 then
    dw_1.selectRow(0, false)
	dw_1.setrow(currentrow)
	dw_1.selectRow(currentrow,true)
    dw_1.scrolltorow(currentrow)
end if
```

### 4.3、隔行换色

```c
//打开数据窗口，选中 detail 区域，找到右侧 color 属性右侧的小图标，在表达式中输入以下代码
if(mod(getrow(),2)=1,rgb(255,255,255),rgb(235,255,235))
```

### 4.4、行序号

添加计算列，在表达式输入框中填写 `getrow()` 即可

### 4.5、移动行

语法：dw_1.rowsmove(开始行,结束行,缓冲区,要移动到的另一窗口名,在哪一行前面插入,插入哪个缓冲区)

缓冲区可选参数：主缓冲区（ primary! ）、删除缓冲区（delete!）、过滤缓冲区（filter!）

```c
//例子：从【删除缓冲区】移动行到【主缓冲区】
dw_1.deleterow(1) //删除第1行 
dw_1.rowsmove(1,dw_1.deletedcount(),delete!,dw_1,1,primary!) //恢复第1行
```

### 4.6、复制行

语法：dw_1.rowscopy(开始行,结束行,缓冲区,要复制到的另一窗口名,在哪一行前面插入,插入哪个缓冲区)

缓冲区可选参数：主缓冲区（ primary! ）、删除缓冲区（delete!）、过滤缓冲区（filter!）

```c
//例1：从【删除缓冲区】复制行到【主缓冲区】
dw_1.deleterow(1) //删除第1行
dw_1.rowscopy(1,1,delete!,dw_1,1,primary!) //复制第1行

//例2：将 dw_2 数据窗口【主缓冲区】中的所有行赋值到 dw_1 数据窗口【主缓冲区】
dw_2.rowscopy(1,dw_2.rowcount(),primary!,dw_1,1,primary!)
```

### 4.7、只读行

```c
//例1：循环设置当前字段每一行的只读状态
long row
for row = 1 to dw_1.rowcount()
	dw_1.Modify("字段名.Protect='" + string(row) + "~tif(表示只读状态字段=1, 1,0)'")
    //控制行为空时只读
    //dw_2.Modify("字段名.Protect='~" + string(row) + "~tif( len( String( trim( 字段名 ) ) ) < 1 or isNull( 字段名 ), 0, 1 )'")
next

//例2：直接设置当前字段所有行的状态
dw_2.modify("字段名.protect=~"0~tif(表达式字段名='表达式字段值' ,1,0)~"")
```

### 4.8、查找行

语法：dw_1.Find ( string 表达式条件, long 开始行, long 结束行) 

返回值：成功时返回查找到的行号（ 大于 0 则表示成功，小于 0 则失败 ）

```c
//例1：查找 id > 100 的数据（ 从第 1 行开始查找，到数据窗口的最后 1 行 ）
dw_1.Find("id > 100", 1, dw_1.RowCount())
    
//例2：查找 name = '张三' 并且 age > 18 的数据（ 从第 5 行开始查找，到第 10 行结束 ）
dw_1.Find("name = '张三' and age > 18 ", 5, 10)
    
//例3：使用变量作为表达式条件（ 从第 5 行开始查找，到第 10 行结束 ）
string ls_name
int li_age
ls_name = '张三'
li_age = 18
dw_1.Find("name = '" + string(ls_name) + "' and age > " + string(ls_age) + " ", 5, 10)
    
//例4：查找 name 等于 null 值的行号（ 从第 1 行开始查找，到数据窗口的最后 1 行 ）
 dw_1.Find("IsNull(name)", 1, dw_1.RowCount()) 
    
//例5：查找 name 中包含 '张三' 的数据
 dw_1.Find("Pos(name,'张三') > 0 ", 1, dw_1.RowCount()) 
    
//例6：循环处理符合条件的行
long ll_find, ll_rowcount
//获取当前数据窗口总行数
ll_rowcount = dw_1.rowcount()
//查找第 1 行到最后 1 行，返回表达式成立的行号
ll_find = dw_1.find('表达式条件', 1, ll_rowcount)
do while ll_find > 0
	//在这里处理查找到所在行的业务...
	ll_find ++
	//防止无休止的循环
	if ll_find > ll_rowcount then exit
	//继续查找下一行
	ll_find = dw_1.find('表达式条件', ll_find, ll_rowcount)
loop
```



## 5、列

### 5.1、列处理

```c
//设置指定列（ 将光标移动到当前列,但不滚动到当前列 ）
dw_1.setcolumn("字段名")
//获取当前列的编号（ 注：具有焦点的列 ）
dw_1.GetColumn()
//获取当前列的名称（ 注：具有焦点的列 ）
dw_1.GetColumnName()
```

### 5.2、获取数据窗口的列名与数据库字段名称

```c
integer li_index
for li_index = 1 to integer(dw_1.object.datawindow.column.count)
	messagebox(string(li_index),dw_1.describe("#" + string(li_index) + ".name")) //数据窗口显示的列名
    messagebox(string(li_index),dw_1.describe("#" + string(li_index) + ".dbname")) //数据库的字段名称
next
```

### 5.3、复制列

```c
dw_1.object.字段名A.primary = dw_1.object.字段名B.primary
```

### 5.4、获取显示列

```
dw_1.describe('DataWindow.Table.GridColumns')
```

### 5.5、设置列为只读

```c
例1、将tab order 设置为0
例2、dw_1.modify("列名.tabsequence = 0  ")
例3、dw_1.modify( "列名.edit.displayonly=yes")
例4、dw_1.modify("列名.protect= 1")
例5、设置列为只读并设置列颜色
    dw_1.modify("列名.tabsequence = 0")
    dw_1.modify("列名.background.color='67108864'") //灰色
    dw_1.modify("列名.background.color='16777215'") //白色
```

### 5.6、选中当前列同时选择内容

```c
dw_1.setcolumn('字段名')
dw_1.selecttext(1,this.SelectTextAll())
dw_1.setfocus()
```

### 5.7、设置焦点

```c
//将当前窗口的焦点移动到 dw_1 控件上
dw_1.setfocus()
//设置第 10 行为当前行，并将焦点移动到当前行
dw_1.setrow(10)
//设置第 10 行中要显示焦点的列
dw_1.setcolumn("字段名") 
```



## 6、过滤

```c
//例1：按列名过滤
dw_1.setfilter("isnull(列名)")
dw_1.filter()

//例2：按条件过滤
dw_1.setfilter("列名='" + 列值 + "'")
dw_1.filter()
    
//例3：清除过滤
//方式1：
dw_1.setfilter('')
dw_1.filter()
//方式2：
dw_1.setfilter('1=1')
    
//例4：SQL语句过滤
sql = 'select * from 表名 where isnull(字段名 , ''空'') = ''空'' ' ;

//例5：in 过滤
dw_1.setfilter("字段名 in(" + 字段值 + ")")
dw_1.filter()
    
//例6：case 过滤
dw_1.setfilter("case( 字段名 when " + 字段值 + " then 1 else 0 ) = 1 ")
```

## 7、排序

### 7.1、数据排序

```c
//例1：正序排列
dw_1.setsort("列名 a") //a 可以替换为 asc
dw_1.sort()

//例2：倒序排列
dw_1.setsort("列名 d") //d 可以替换为 desc
dw_1.sort()
```

### 7.2、双击排序

```c
string ls_old_sort, ls_column
char  lc_sort
if right(dwo.name,2) = '_t' then
	ls_column = left(dwo.name, len(string(dwo.name)) - 2)
	ls_old_sort = this.describe("datawindow.table.sort")
	if ls_column = left(ls_old_sort,  len(ls_old_sort) - 2)  then
		lc_sort = right(ls_old_sort, 1)
		if lc_sort = 'a' then
			lc_sort = 'd'
		else
			lc_sort = 'a'
		end if
		this.setsort(ls_column + " " + lc_sort)
	else
		this.setsort(ls_column + "  a")
	end if
	this.sort()
end if
```

### 7.3、移动排序

（1）、置顶

```c
long ll_row
ll_row = dw_1.getrow()
if ll_row > 0 then
	dw_1.rowsmove(ll_row,ll_row,primary!,dw_1,1,primary!)
	dw_1.setrow(1)
	dw_1.scrolltorow(1)
	dw_1.event rowfocuschanged(1)
end if
```

（2）、上移

```c
long ll_row
ll_row = dw_1.getrow()
IF ll_row > 1 THEN
	dw_1.rowsmove(ll_row,ll_row,primary!,dw_1,ll_row - 1,primary!)
	dw_1.setrow(ll_row - 1)
	dw_1.scrolltorow(ll_row - 1)
	dw_1.EVENT rowfocuschanged(ll_row - 1)
END IF
```

（3）、下移

```c
long ll_row
ll_row = dw_1.getrow()
IF ll_row < dw_1.rowcount() THEN
	dw_1.rowsmove(ll_row,ll_row,primary!,dw_mx,ll_row + 2,primary!)
	dw_1.setrow(ll_row + 1)
	dw_1.scrolltorow(ll_row + 1)
	dw_1.EVENT rowfocuschanged(ll_row + 1)
END IF
```

（4）、末尾

```c
long ll_row,ll_count
ll_row = dw_1.getrow()
ll_count = dw_1.rowcount()
IF ll_row > 0 THEN
	dw_1.rowsmove(ll_row,ll_row,primary!,dw_1,ll_count+1,primary!)
	dw_1.setrow(ll_count)
	dw_1.scrolltorow(ll_count)
	dw_1.EVENT rowfocuschanged(ll_count)
END IF
```

## 8、分页

（1）、表达式分页

```c
1、增加一个计算列并命名为 row_page（ 此计算列必须放在detail段 ）
然后在 expression 中输入表达式

ceiling(getrow()/10) //此表达式代表每页显示 10 行，根据需要可以自己修

2、根据分页字段 row_page 创建分组
菜单位置：rows—>create group—>将 row_page 字段拖动到右侧
然后看右侧分组属性中，将 new page on group break 选中。
3、如果你的页尾有内容，那么请将页尾内容放到 row_page 组区域
4、最后，将此计算列设为不可视（ 如果只是设计数据窗口，那么做到这一步就已经可以了 ）
```

（2）、数据窗口分页

```c
//首页
dw_1.scrolltorow(0)
dw_1.setrow(0)
    
//上一页
dw_1.scrollpriorpage()
    
//下一页
dw_1.scrollnextpage()
    
//尾页
dw_1.scrolltorow(dw_1.rowcount())
dw_1.setrow(dw_1.rowcount())
```

## 9、SQL

```c
//例1：获取数据窗口 SQL 语句
dw_1.getsqlselect()
    
//例2：设置数据窗口的 SQL 语句
string ls_sql
ls_sql = 'select * from test'
dw_1.setsqlselect(sql)
    
//例3：在数据窗口 SQL 中传递 in 数组
//注：在传给数据窗口时，in中的内容必须是数组类型
string ls_in[]
for i = 1 to dw_1.rowcount()
 ls_in[i] =  string(dw_1.object.test[i])
next
dw_1.retrieve(ls_in)
```

## 10、子数据窗口

```c
integer rtncode
datawindowchild dwc_child
rtncode = dw_1.getchild("主窗口字段", dwc_child)
if rtncode = 1 then
	messagebox('',dwc_child.getitemstring(1,'子窗口字段'))
else
	messagebox('提示','未获取到子数据窗口!')
end if
```

## 11、DataStore

> 不可视数据窗口

```c
datastore lds_test
lds_test = create  datastore

//关联数据窗口
lds_test.dataobject =  'd_main'

//指定事务
lds_test.settransobject(sqlca)

//接下来就和操作普通数据窗口一样了（例）
lds_test.insertrow(0)
lds_test.object.title[1]  = '我是测试标题'
messagebox('',string(lds_test.object.title[1]))

destroy lds_test
```

## 12、导入导出

（1）、导入

```c
//dw_1.importfile(导入的文件类型, 文件名, 文件的开始行 , 文件的结束行, 文件的开始列, 文件的结束列, 数据窗口的开始列 )
//因为导出的数据窗口都有标题，所以我们这边从第2行开始导入
dw_1.importfile(text!,'1.txt',2,10,1,10,1) //导入txt文件
dw_1.importfile(excel!,'1.xls',2,10,1,10,1) //导入xls文件
dw_1.importfile(excel!,'1.xlsx',2,10,1,10,1)//导入xlsl文件
dw_1.importfile(csv!,'1.csv',2,10,1,10,1)//导入csv文件
```

（2）、导出

```c
//dw_name.saveas(名字可含路径,另存为的类型,是否显示列标题)
dw_1.saveas("1.txt",text!,true)  //另存为txt文件
dw_1.saveas("1.xls",excel!,true) //另存为xls文件
dw_1.saveas("1.xlsx",excel!,true) //另存为xlsl文件
dw_1.saveas("1.csv",csv!,true) //另存为csv文件
```

## 13、设置当前行指示图标

```c
//1、在数据窗口中建立一个计算列,expression 为 '' ,并将该计算列移动为 datawindow 的第一个列
//2、在数据窗口的 rowfocuschanged 事件中写入以下代码

SetRowFocusIndicator(hand!) //小手指样式
setrowfucsindicator(p_1) //自定义图片样式
```

## 14、自动高度

（1）、点中 Detail Band (即写有Detail的灰色长带), 选中右侧的 Autosize Height 多选框

（2）、点击你要设置的列名

（3）、选择右侧的 Position 选项, 选中 Autosize Height 多选框

（4）、选择右侧的Edit选项，去掉Auto Horz Scroll并勾选Auto Vert Scroll

（5）、使用 SQL 语句完成数据换行

```c
//制表符： CHAR(9)
//换行符： CHAR(10)
//回车符： CHAR(13)
select char(10) + 字段名 from 表名
```

## 15、控件

### 15.1、多选框

（1）、在数据窗口的sql中，添加多选框字段

```
'ls_checkbox' = '0',
```

（2）、设置字段的`edit`属性为`checkbox`，并勾选`3d look`

（3）、设置(data value for on = 1)，设置(data value for off = 0)

（4）、再dw_1数据窗口的click事件中写

```c
if dwo.name = "ls_checkbox_t" then
	if dw_1.rowcount() = 0 then
	else
		if  dw_1.object.ls_checkbox[1] = "1" then
			for row = 1 to  dw_1.rowcount()
				dw_1.object.ls_checkbox[row] = "0"
			next
		else
			for row = 1 to  dw_1.rowcount()
				dw_1.object.ls_checkbox[row] = "1"
			next
		end  if
	end if
end if
```

（5）、取值

```c
long cbx_i
if  dw_1.rowcount() = 0 then return 0
for cbx_i = 1 to dw_1.rowcount()
	
	//取字符
	if  dw_1.getitemstring(cbx_i, "ls_checkbox") = '1' then
	end if
	
	//取数值
	if dw_1.getitemnumber(1, 'ls_checkbox') = 1 then
	end if
	
next
```

### 15.2、下拉框

（1）、设置为只读

```c
dw_1.modify("字段名.dddw.allowedit=no")
```

（2）、获取显示值

```c
long row
row = 1 //row 是下拉框中的行号
dw_1.Describe("Evaluate('LookupDisplay(字段名)'," + string(row) + ")")
```

（3）、添加角标

```c
dw_1.modify("字段名.dddw.useasborder=yes")
dw_1.Modify("字段名.edit.case='any'")   
dw_1.Modify("字段名.edit.AutoSelect='Yes'")
```

## 16、打印

### 16.1、将数据窗口打印为 PDF 文件

```c
dw_1.object.datawindow.print.filename ="c:/temp.pdf"
dw_1.print()
```

### 16.2、分组聚合打印

```c
/*
1、选中分组带，不要勾选  New Page on Group Break
注：聚合打印的核心就是将表头内容添加到 header group ... 中
*/

//2、如果要对聚合的分组定义序号，可以添加计算列，并写入以下表达式（ 可选 ）
getrow() - first(getrow() for group  1) + 1
```

### 16.3、补足空行

```c
long ll_pagerow,ll_count

//每页打印行数
ll_pagerow = 10

//取得现有报表的总行数
ll_count = dw_report.retrieve()

//每页相差的空行数
ll_count = ll_pagerow - mod(ll_count, ll_pagerow)

If ll_count < ll_pagerow Then
	long ll_row
	//循环补足空行
	for ll_row = 1 to ll_count
		dw_print.insertrow(0) 
	next
end If
```

## 17、其他

### 17.1、将Grid风格改成自由格式

```c
在 DW 的 editsource 中将 processing = 1 的 1 改为 0
```

### 17.2、屏蔽回车后自动跳行

```c
//pbm_dwnprocessenter 事件中写入代码  
return 1
```

### 17.3、执行父数据窗口事件

```c
call super::constructor
```

### 17.4、文本竖排显示与旋转

```
1、字体修改为 @宋体
2、修改字体属性中的参数 Escapement 为 2700
```

